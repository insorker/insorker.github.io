<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态规划——埋葬故国武士的灵魂</title>
      <link href="2020/10/13/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>2020/10/13/%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划——埋葬故国武士的灵魂"><a href="#动态规划——埋葬故国武士的灵魂" class="headerlink" title="动态规划——埋葬故国武士的灵魂"></a>动态规划——埋葬故国武士的灵魂</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这是百度百科给出的动态规划的基本概念：</p><blockquote><p>如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策（采取措施），一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题。</p><p>各个阶段的决策构成一个决策序列，称为一个策略。每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取，对应于一个策略可以确定活动的效果，这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果。</p></blockquote><p>我看过一个非常生动的解释</p><blockquote><p>Insorker：如何向一个四岁小孩解释动态规划？</p><p>Carve：”1 + 1 + 1 + 1 + 1 + 1 + 1 + 1“等于几？</p><p>。。。（3秒后）</p><p>Insorker：8！</p><p>Carve：如果再加上1呢</p><p>Insorker：9！</p><p>Carve：你是如何算这么快的呢？</p><p>Insorker：前面的1已经算过了。</p><p>Carve：O(∩_∩)O</p><p>Insorker：我明白了，我是记住了之前的答案，而不是再算一遍，也就是说我用我的大脑记忆代替了计算的时间花费。</p></blockquote><p>那么我个人对动态规划的理解是：</p><p>通过把大问题拆分成一堆递进的小问题，依次求每个小问题的解，最后获得整体上的解。</p><p>或者换句话说，</p><blockquote><p>一个这样的迷宫，每走过一个格子加上格子上的数，只能向下或者向右前进，初始是0：</p><p>S 2 3 2</p><p>2 1 4 1</p><p>1 1 2 1</p><p>2 3 1 E</p><p>如何才能最终以最大的和，从 S 走到 E ？</p></blockquote><p>一种方法是我把所有路径都算一遍，就是2 + 3 + 2 + 1 + 1这种走法算一遍，2 + 3 + 4 + 2 + 1也算一遍，这样要算 20 遍数据。但是我们可以很清楚的看见2 + 3这个部分被算了两次，这显然是在浪费时间。虽然每次计算我们开出来的数组很小，但是时间复杂度是20，如果这个迷宫是10 * 10的迷宫，则复杂度上升到了252，如果是 n * n 呢？则时间复杂度会是（约为）$\frac{n!}{(\frac{n}{2})!(\frac{n}{2})!}$（杨辉三角）。。。</p><p>所以我们肯定需要某种方法来减少时间上的复杂度，不用说肯定是利用空间啦(〝▼皿▼)</p><p>我们可以写出一个dp数组，保存我们走过的路的最优解，所以每个小问题就是：走到（x，y）的最优解是什么。同时我们也可以列出递推式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[x][y] = max(dp[x - <span class="number">1</span>][y], dp[x][y - <span class="number">1</span>]) + v;</span><br></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><blockquote><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>有<strong>N</strong>件物品和一个容量是<strong>V</strong>的背包。</p><p>每件物品只能使用一次。</p><p>第<strong>i</strong>件物品体积是<strong>v<del>i</del>**，价值是</strong>w<del>i</del>**。</p><p>求解将哪些物品装入背包，可使这些物品的总体积不超过背包的容量，且总价值最大。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示最大价值。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>0 &lt; <em>N</em>, <em>V</em> ≤ 1000<br>0 &lt; <em>v<del>i</del></em>,  <em>w<del>i</del></em> ≤ 1000</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure></blockquote><p>二维数组的情况很好理解，我们用<code>dp[i][j]</code>来表示取到第<strong>i</strong>个物品时，总容量为<strong>j</strong>的最优解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;w, &amp;v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt; <span class="number">0</span>; j -- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; w)</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w] + v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是一维数组就非常令人费解。</p><p>首先为什么要变一维数组，很显然是为了省空间，那可以省空间吗？</p><p>答案是肯定的。我们可以发现<code>dp[1][j]</code>在循环一次后就再也没有用到，这是为什么呢？</p><p>这是从定义出发导致的失误，每次我们算出来的结果，都是前<strong>i</strong>个物品在总量为<strong>j</strong>的情况下的最优解，但是我们并不需要记录这个最优解，所以可以优化为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w &gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j; j -- )</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w)</span><br><span class="line">                dp[j] = max(dp[j], dp[j - w] + v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锵锵，是不是很神奇呢~~</p><p>原理很简单，我们只是把<strong>i</strong>省掉了，意思是放弃了记录所有前<strong>i</strong>个物品的最优解，转而只保存第<strong>i</strong>个物品的最优解。换句话说，就是现在记录的<code>dp[j]</code>其实就是<code>dp[i][j]</code>，只是其他的<strong>“i”</strong>我们不管了 哼，哼(▼へ▼メ)。</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心——古神的盛宴</title>
      <link href="2020/10/11/%E7%AE%97%E6%B3%95%EF%BC%9A%E8%B4%AA%E5%BF%83/"/>
      <url>2020/10/11/%E7%AE%97%E6%B3%95%EF%BC%9A%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心——古神的盛宴"><a href="#贪心——古神的盛宴" class="headerlink" title="贪心——古神的盛宴"></a>贪心——古神的盛宴</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在最前面</title>
      <link href="2020/10/11/%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2/"/>
      <url>2020/10/11/%E5%86%99%E5%9C%A8%E6%9C%80%E5%89%8D%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>slides</title>
      <link href="slides/index.html"/>
      <url>slides/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>404</title>
      <link href="/404.html"/>
      <url>/404.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类(^_−)☆</title>
      <link href="categories/index.html"/>
      <url>categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签o(´^｀)o</title>
      <link href="tags/index.html"/>
      <url>tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>

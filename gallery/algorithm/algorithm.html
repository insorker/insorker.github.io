<!DOCTYPE html>
<html lang="en">
<head>
    

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>algorithm</title>
    <link rel="shortcut icon" type="image/x-icon" href="/img/favicon.ico" />
    <link href="/css/yori.css" rel="stylesheet" />
    
    <link rel="stylesheet" href="/css/github-markdown.min.css">
    <link rel="stylesheet" href="/css/github.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <style type="text/css">
        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }

        @media (max-width: 767px) {
            .markdown-body {
                padding: 15px;
            }
        }
    </style>

</head>
<body>
    <div class="container">
    
        <div id="content">
            
    <div class="content-header">
        <div class="post-title">
            algorithm
        </div>
        <div class="post-meta">
            <span>insorker</span>
            <span> | posted on 2022-03-16</span>
        </div>
    </div>
    <div class="markdown-body">
        <h1 id="_1">前言</h1>
<p>因为自己不善于总结而吃了亏。</p>
<p>所以，前有总结</p>
<h2 id="_2">基础</h2>
<h3 id="_3">二分</h3>
<pre class="highlight"><code class="language-c++">// 看if判断的语义，如q[mid] &gt; x就是大于x的最小的数，q[mid] &lt;= x就是小于等于x的最大的数
int l = 0, r = n - 1;
while (l &lt; r) {
    int mid = l + r &gt;&gt; 1;
    if (q[mid] &gt; x) r = mid;
    else l = mid + 1;
}

int l = 0, r = n - 1;
while (l &lt; r) {
    int mid = l + r + 1 &gt;&gt; 1;
    if (q[mid] &gt; x) l = mid;
    else r = mid - 1;
}</code></pre>
<h3 id="_4">链表</h3>
<pre class="highlight"><code class="language-c++">int h, e[N], ne[N], idx;

void init() { h = -1; idx = 0; }
void add_to_head(int v) {
    e[idx] = v, ne[idx] = h, h = idx ++ ;
}
void add(int k, int v) {
    e[idx] = v, ne[idx] = ne[k], ne[k] = idx ++ ;
}
void remove(int k) {
    ne[k] = ne[ne[k]];
}</code></pre>
<h3 id="_5">前缀和</h3>
<pre class="highlight"><code class="language-c++">int a[N], s[N];

int main() {
    for (int i = 1; i &lt;= n; i ++ ) s[i] = a[i] + s[i - 1];
}</code></pre>
<h3 id="_6">差分</h3>
<pre class="highlight"><code class="language-c++">int a[N], b[N];

void add(int l, int r, int v) {
    b[l] += v;
    b[r + 1] -= v;
}

int main() {
    for (int i = 1; i &lt;= n; i ++ ) add(i, i, a[i]);
}</code></pre>
<h3 id="_7">并查集</h3>
<pre class="highlight"><code class="language-c++">int p[N];

void init() {
    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;
}
int find(int x) {
    if (p[x] != x)
        p[x] = find(p[x]);
    return p[x];
}</code></pre>
<h3 id="_8">单调栈</h3>
<pre class="highlight"><code class="language-c++">int stk[N], tt;

// 存距离最近的最大的数
void add(int v) {
    while (tt &amp;&amp; stk[tt] &lt;= v) tt -- ;
    stk[ ++ tt] = v;
}</code></pre>
<h3 id="_9">单调队列</h3>
<h2 id="_10">数学</h2>
<h3 id="gcd">gcd</h3>
<pre class="highlight"><code class="language-c++">int gcd(int a, int b) {
    // a &gt;= b;
    while (b) {
        int tmp = a % b;
        a = b;
        b = tmp;
    }
    return a;
}</code></pre>
<h3 id="_11">快速幂</h3>
<pre class="highlight"><code class="language-c++">typedef long long LL;
LL qmi(int a, int b, int p) {
    int res = 1 % p;
    while (b) {
        if (b &amp; 1) res = res * (LL)a % p;
        a = a * (LL)a % p;
        b &gt;&gt;= 1;
    }
    return res;
}</code></pre>
<h2 id="_12">字符串</h2>
<h3 id="trie">Trie树</h3>
<pre class="highlight"><code class="language-c++">// 这里以26个字母的字符串建树为例子，N是字符串最长长度
int son[N][26], cnt[N], idx;
char str[N];

// 在trie树中插入一条字符串
void insert(char *str) {
    int p = 0;
    for (int i = 0; str[i]; i ++ ) {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx; // 下一个字母的下标
                                            // 因为需要用0判断son是否为空，所以是 ++idx
        p = son[p][u];
    }
    cnt[p] ++ ; // 表示以下标p结尾的字符串个数加1
}

int query(char *str) {
    int p = 0;
    for (int i = 0; str[i]; i ++ ) {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p]; // 返回出现了几次
}</code></pre>
<h2 id="_13">图论</h2>
<h3 id="dijkstra">朴素dijkstra</h3>
<blockquote>
<p>O(n^2)，处理稠密图</p>
</blockquote>
<pre class="highlight"><code class="language-c++">int n, m;
int g[N][N];
int dist[N];
bool st[N];

int dijkstra() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i &lt; n; i ++ ) {
        int t = -1;
        for (int j = 1; j &lt;= n; j ++ )
            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))
                t = j;

        st[t] = true;
        for (int j = 1; j &lt;= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    else return dist[n];
}

int main() {
    memset(g, 0x3f, sizeof g);

    while (m -- ) {
        int a, b, c;
        scanf("%d%d%d", &amp;a, &amp;b, &amp;c);
        g[a][b] = min(g[a][b], c);
    }
}</code></pre>
<h3 id="dijkstra_1">堆优化Dijkstra</h3>
<blockquote>
<p>复杂度忘了，反正稀疏图</p>
</blockquote>
<pre class="highlight"><code class="language-c++">typedef pair&lt;int, int&gt; PII;

int n, m;
int h[N], e[N], w[N], ne[N], idx;
int dist[N];
bool st[N];

void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int dijkstra() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    priority_queue&lt;PII&gt; heap;
    heap.push({ dist[1], 1 });

    while (heap.size()) {
        auto tt = heap.top(); heap.pop();

        int ver = tt.second;
        if (st[ver]) continue;

        for (int i = h[ver]; i != -1; i = ne[i]) {
            int j = e[i], k = w[i];
            if (dist[j] &gt; dist[ver] + k) {
                dist[j] = dist[ver] + k;
                heap.push({ dist[j], j });      // 记得push一下
            }
        }
        st[ver] = true;     // 减少循环次数
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    else return dist[n];
}

int main() {
    memset(h, -1, sizeof h);
}</code></pre>
<h3 id="bellman-ford">bellman-ford</h3>
<pre class="highlight"><code class="language-c++">int n, m, k;
int dist[N], bak[N];    // N个点
struct Edge {
    int a, b, w;
} edges[M];             // M条边

int bellman_ford() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i &lt; k; i ++ ) {         // 循环k次，走k步
        memcpy(bak, dist, sizeof dist);     // 备份一下
        for (int j = 0; j &lt; m; j ++ ) {
            int &amp;e = edges[j];
            dist[e.b] = min(dist[e.b], bak[e.a] + e.w);
        }
    }

    if (dist[n] &gt; 0x3f3f3f3f / 2) return "impossible";  // 因为最后一条边是肯定会被更新的，但不一定能走到
    else return dist[n];
}</code></pre>
<h3 id="spfa">spfa</h3>
<pre class="highlight"><code class="language-c++">int n, m;
int h[N], e[N], w[N], ne[N], idx;
int dist[N];
bool st[N];

void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int spfa() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue&lt;int&gt; q;
    q.push(1);
    st[1] = true;       // st表示的是元素是否在队列中

    while (q.size()) {
        auto tt = q.front(); q.pop();
        st[tt] = false;

        for (int i = h[tt]; i != -1; i = ne[i]) {
            int j = e[i], k = w[i];
            if (dist[j] &gt; dist[tt] + k) {
                dist[j] = dist[tt] + k;
                if (!st[j]) {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return "impossible"; // 不能return-1，因为有可能dist[n] == -1
    else return dist[n];
}

int main() {
    memset(h, -1, sizeof h);
}</code></pre>
<h3 id="floyd">Floyd</h3>
<pre class="highlight"><code class="language-c++">const int INF = 1e9;
int n, m;
int dist[N][N];

int floyd() {
    for (int k = 1; k &lt;= n; k ++ )
        for (int i = 1; i &lt;= n; i ++ )
            for (int j = 1; j &lt;= n; j ++ )
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
}

int main() {
    for (int i = 1; i &lt;= n; i ++ )
        for (int j = 1; j &lt;= n; j ++ )
            if (i == j) dist[i][j] = 0;
            else dist[i][j] = INF;

    for (int i = 0; i &lt; m; i ++ ) {
        int a, b, c;
        scanf("%d%d%d", &amp;a, &amp;b, &amp;c);
        dist[a][b] = min(dist[a][b], c);
    }

    // 查询x，y
    if (dist[x][y] &gt; INF / 2) false;    // 所有边都会更新
    else dist[x][y];
}</code></pre>
<h3 id="_14">最小生成树</h3>
<h4 id="prim">Prim</h4>
<pre class="highlight"><code class="language-c++">const int INF = 0x3f3f3f3f;
int n, m;
int g[N][N];
int dist[N];
bool st[N];

int prim() {
    memset(dist, 0x3f, sizeof dist);

    int res = 0;
    for (int i = 0; i &lt; n; i ++ ) {
        int t = -1;
        for (int j = 1; j &lt;= n; j ++ )
            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))
                t = j;

        if (i &amp;&amp; dist[t] == INF) return INF;
        if (i) res += dist[t];
        st[t] = true;

        for (int j = 1; j &lt;= n; j ++ )
            if (!st[j]) dist[j] = min(dist[j], g[t][j]);
    }

    return res;
}
// 因为最小生成树是无向图，注意一下初始化
g[a][b] = g[b][a] = min(g[a][b], c);</code></pre>
<h4 id="kruskal">Kruskal</h4>
<pre class="highlight"><code class="language-c++">int n, m;
int p[N]; // 并查集
struct Edge {
    int a, b, w;
    bool operator&lt;(const struct Edge &amp;e) const {
        return w &lt; e.w;
    }
} edges[N];

int find(int a) {
    if (p[a] != a) p[a] = find(p[a]);
    return p[a];
}

int main() {
    for (int i = 0; i &lt; m; i ++ ) {
        int a, b, w;
        scanf("%d%d%d", &amp;a, &amp;b, &amp;w);
        edges[i] = { a, b, w };
    }
    sort(edges, edges + m);

    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;

    int res = 0, cnt = 0;   // 最小生成树边权重和，边数
    for (int i = 0; i &lt; m; i ++ ) {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        a = find(a), b = find(b);
        if (a != b) {
            res += w;
            p[a] = b;
            cnt ++ ;
        }
    }
    if (cnt &lt; n - 1) false; // 因为n个点有n-1条边，如果达不到，说明不是连通图
    else res;
}</code></pre>
<h2 id="_15">动态规划</h2>
<h3 id="01">01背包问题</h3>
<pre class="highlight"><code class="language-c++">    for (int i = 1; i &lt;= n; i ++ )
        for (int j = m; j &gt;= v[i]; j -- )
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout &lt;&lt; f[m] &lt;&lt; endl;</code></pre>
<hr />
    </div>
    
            

    <div id="gitalk-container"></div>

        </div>
        <div id="footer">
            
            
        </div>
        

        
    <script src="/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <script>
        const gitalk = new Gitalk({
            clientID: '1c8b8a648872fb4b06e5',
            clientSecret: 'e7aa56cb8653e89050195484e973f5de0cb46781',
            repo: 'insorker.github.io', // The repository of store comments,
            owner: 'insorker',
            admin: ['insorker'],
            id: 1648734494.5308437, // Ensure uniqueness and length less than 50
            distractionFreeMode: false  // Facebook-like distraction free mode
        })
        gitalk.render('gitalk-container')
    </script>

    
    </div>
</body>
</html>
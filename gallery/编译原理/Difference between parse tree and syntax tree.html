<!DOCTYPE html>
<html lang="en">
<head>
    

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Difference between parse tree and syntax tree</title>
    <link rel="shortcut icon" type="image/x-icon" href="/img/favicon.ico" />
    <link href="/css/yori.css" rel="stylesheet" />
    
    <link rel="stylesheet" href="/css/github-markdown.min.css">
    <link rel="stylesheet" href="/css/github.min.css">
    <style type="text/css">
        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }

        @media (max-width: 767px) {
            .markdown-body {
                padding: 15px;
            }
        }
    </style>

</head>
<body>
    <div class="container">
    
        <div id="content">
            
    <div class="content-header">
        <div class="post-title">
            Difference between parse tree and syntax tree
        </div>
        <div class="post-meta">
            <span>insorker</span>
            <span> | posted on 2022-03-30</span>
        </div>
    </div>
    <div class="markdown-body">
        <p>From: <a href="https://stackoverflow.com/questions/5026517/whats-the-difference-between-parse-trees-and-abstract-syntax-trees-asts">https://stackoverflow.com/questions/5026517/whats-the-difference-between-parse-trees-and-abstract-syntax-trees-asts</a></p>
<hr />
<p>Here's an explanation of <strong>parse trees</strong> (concrete syntax trees, CSTs) and <strong>abstract syntax trees</strong> (ASTs), in the context of compiler construction. They're similar data structures, but they're constructed differently and used for different tasks.</p>
<h1 id="parse-trees">Parse trees</h1>
<p>Parse trees are usually generated as the next step after lexical analysis (which turns the source code into a series of tokens that can be viewed as meaningful units, as opposed to just a sequence of characters).</p>
<p>They are tree-like data structures that shows how an input string of terminals (source code tokens) has been generated by the grammar of the language in question. The root of the parse tree is the most general symbol of the grammar - the start symbol (for example, <em>statement</em>), and the interior nodes represent nonterminal symbols that the start symbol expands to (can include the start symbol itself), such as <em>expression</em>, <em>statement</em>, <em>term</em>, <em>function call</em>. The leaves are the terminals of the grammar, the actual symbols which appear as identifiers, keywords, and constants in the language / input string, e.g. <strong>for</strong>, <strong>9</strong>, <strong>if</strong>, etc.</p>
<p>While parsing the compiler also performs various checks to ensure the correctness of syntax - and and syntax error reports can be imbedded into parser code.</p>
<p>They can be used for syntax-directed translation via syntax-directed definitions or translation schemes, for simple tasks such as converting an infix expression to a postfix one.</p>
<p>Here's a graphical representation of a parse tree for the expression <code>9 - 5 + 2</code> (note the placement of the terminals in the tree and the actual symbols from the expression string):</p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/a0j2y.png" /></p>
<h1 id="abstract-syntax-trees">Abstract syntax trees</h1>
<p>ASTs represent the syntactic <em>structure of the some code</em>. The trees of programming constructs such as expressions, flow control statements, etc - grouped into operators (interior nodes) and operands (leaves). For example, the syntax tree for the expression <code>i + 9</code> would have the operator <code>+</code> as root, the variable <code>i</code> as the operator's left child, and the number <code>9</code> as the right child.</p>
<p>The difference here is that nonterminals and terminals don't play a role, as ASTs don't deal with grammars and string generation, but programming constructs, and thus they represent relationships between such constructs, and not the ways they are generated by a grammar.</p>
<p>Note that the operators themselves are programming constructs in a given language, and don't have to be actual computational operators (like <code>+</code> is): <code>for</code> loops would also be treated in this way. For example, you could have a syntax tree such as <code>for [ expr, expr, expr, stmnt ]</code> (represented inline), where <code>for</code> is an <em>operator</em>, and the elements inside the square brackets are its children (representing C's <code>for</code> syntax) - also composed out of operators etc.</p>
<p>ASTs are usually generated by compilers in the syntax analysis (parsing) phase as well, and are used later for semantic analysis, intermediate representation, code generation, etc.</p>
<p>Here's a graphical representation of an AST:</p>
<p><img alt="enter image description here" src="https://i.stack.imgur.com/Rr2Cm.png" /></p>
    </div>
    
            

        </div>
        <div id="footer">
            
            
        </div>
        

        
    <script src="/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    
    </div>
</body>
</html>
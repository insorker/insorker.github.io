<!DOCTYPE html>
<html lang="en">
<head>
    

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第 289 场周赛</title>
    <link rel="shortcut icon" type="image/x-icon" href="/img/favicon.ico" />
    <link href="/css/yori.css" rel="stylesheet" />
    
    <link rel="stylesheet" href="/css/github-markdown.min.css">
    <link rel="stylesheet" href="/css/github.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
    <style type="text/css">
        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }

        @media (max-width: 767px) {
            .markdown-body {
                padding: 15px;
            }
        }
    </style>

</head>
<body>
    <div class="container">
    
        <div id="content">
            
    <div class="content-header">
        <div class="post-title">
            第 289 场周赛
        </div>
        <div class="post-meta">
            <span>insorker</span>
            <span> | posted on 2022-04-17</span>
        </div>
    </div>
    <div class="markdown-body">
        <h1 id="289">第 289 场周赛</h1>
<h1 id="t1">T1</h1>
<p>ans忘记初始化为s了，wa了一发</p>
<pre class="highlight"><code class="language-c++">class Solution {
public:
    void merge(string before, string &amp;after, int k) {
        if (before.size() &lt;= k) {
            return;
        }

        after.clear();
        for (int i = 0; i &lt; before.size(); i += k) {
            int num = 0;
            for (int j = i; j &lt; i + k &amp;&amp; j &lt; before.size(); j ++ ) {
                num += before[j] - '0';
            }
            after += to_string(num);
        }
        merge(after, after, k);
    }

    string digitSum(string s, int k) {
        string ans = s;
        merge(s, ans, k);
        return ans;
    }
};</code></pre>
<h2 id="t2">T2</h2>
<p>花费的时间有点久</p>
<pre class="highlight"><code class="language-c++">class Solution {
public:
    int minimumRounds(vector&lt;int&gt;&amp; tasks) {
        sort(tasks.begin(), tasks.end());

        int cnt = 1, ans = 0;
        int curr = tasks[0];
        for (int i = 1; i &lt; tasks.size(); i ++ ) {
            if (tasks[i] != curr) {
                if (cnt &lt; 2) return -1;
                if (cnt == 2) {
                    ans += 1;
                    curr = tasks[i];
                    cnt = 1;
                    continue;
                }
                if (cnt % 3 == 1) ans += cnt / 3 + 1;
                if (cnt % 3 == 2) ans += cnt / 3 + 1;
                if (cnt % 3 == 0) ans += cnt / 3;

                curr = tasks[i];
                cnt =1;
            }
            else {
                cnt ++ ;
            }
        }

        if (cnt &lt; 2) return -1;
        if (cnt == 2) ans += 1;
        else {
        if (cnt % 3 == 1) ans += cnt / 3 + 1;
        if (cnt % 3 == 2) ans += cnt / 3 + 1;
        if (cnt % 3 == 0) ans += cnt / 3;}

        return ans;
    }
};</code></pre>
<h2 id="t3">T3</h2>
<p>前缀和的题目，很简单，就是写起来很复杂。只能说我的水平还是有点菜，其实早就能做出来的，硬是拖到时间结束</p>
<pre class="highlight"><code class="language-c++">typedef struct nx {
    int n0, n2, n5;
} nx;

class Solution {
public:
    void assign(nx &amp;s1, nx &amp;s2) {
        s1.n0 = s2.n0;
        s1.n2 = s2.n2;
        s1.n5 = s2.n5;
    }

    void getx(nx &amp;n, int x) {
        while (x &amp;&amp; x % 10 == 0) {
            n.n0 ++ ;
            x /= 10;
        }
        while (x &amp;&amp; x % 2 == 0) {
            n.n2 ++ ;
            x /= 2;
        }
        while (x &amp;&amp; x % 5 == 0) {
            n.n5 ++ ;
            x /= 5;
        }
    }

    void update(nx &amp;s1, nx &amp;s2, int x) {
        assign(s1, s2);
        int n0 = 0, n2 = 0, n5 = 0;
        while (x &amp;&amp; x % 10 == 0) {
            n0 ++ ;
            x /= 10;
        }
        while (x &amp;&amp; x % 2 == 0) {
            n2 ++ ;
            x /= 2;
        }
        while (x &amp;&amp; x % 5 == 0) {
            n5 ++ ;
            x /= 5;
        }
        s1.n0 += n0, s1.n2 += n2, s1.n5 += n5;
    }

    int maxTrailingZeros(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int n = grid.size(), m = grid[0].size();
        vector&lt;vector&lt;vector&lt;nx&gt;&gt;&gt; s(n + 1, vector&lt;vector&lt;nx&gt;&gt;(m + 1, vector&lt;nx&gt;(3)));

        for (int i = 1; i &lt;= n; i ++ ) {
            for (int j = 1; j &lt;= m; j ++ ) {
                update(s[i][j][0], s[i - 1][j][0], grid[i - 1][j - 1]);
                update(s[i][j][1], s[i][j - 1][1], grid[i - 1][j - 1]);
            }
        }

        int maxv = 0;
        for (int i = 1; i &lt;= n; i ++ ) {
            for (int j = 1; j &lt;= m; j++ ) {

                nx x;
                {
                    x.n0 = x.n2 = x.n5 = 0;
                    getx(x, grid[i - 1][j - 1]);
                    x.n0 = -x.n0, x.n2 = -x.n2, x.n5 = -x.n5;
                    x.n0 += s[i][j][0].n0 + s[i][j][1].n0;
                    x.n2 += s[i][j][0].n2 + s[i][j][1].n2;
                    x.n5 += s[i][j][0].n5 + s[i][j][1].n5;
                    maxv = max(maxv, min(x.n2, x.n5) + x.n0);
                }

                {
                    x.n0 = x.n2 = x.n5 = 0;
                    x.n0 += (s[n][j][0].n0 - s[i][j][0].n0) + s[i][j][1].n0;
                    x.n2 += (s[n][j][0].n2 - s[i][j][0].n2) + s[i][j][1].n2;
                    x.n5 += (s[n][j][0].n5 - s[i][j][0].n5) + s[i][j][1].n5;
                    maxv = max(maxv, min(x.n2, x.n5) + x.n0);
                }

                {
                    x.n0 = x.n2 = x.n5 = 0;
                    x.n0 += s[i][j][0].n0 + (s[i][m][1].n0 - s[i][j][1].n0);
                    x.n2 += s[i][j][0].n2 + (s[i][m][1].n2 - s[i][j][1].n2);
                    x.n5 += s[i][j][0].n5 + (s[i][m][1].n5 - s[i][j][1].n5);
                    maxv = max(maxv, min(x.n2, x.n5) + x.n0);
                }

                {
                    x.n0 = x.n2 = x.n5 = 0;
                    getx(x, grid[i - 1][j - 1]);
                    x.n0 += (s[n][j][0].n0 - s[i][j][0].n0) + (s[i][m][1].n0 - s[i][j][1].n0);
                    x.n2 += (s[n][j][0].n2 - s[i][j][0].n2) + (s[i][m][1].n2 - s[i][j][1].n2);
                    x.n5 += (s[n][j][0].n5 - s[i][j][0].n5) + (s[i][m][1].n5 - s[i][j][1].n5);
                    maxv = max(maxv, min(x.n2, x.n5) + x.n0);
                }
            }
        }

        return maxv;
    }
};</code></pre>
<h2 id="t4">T4</h2>
<p>【补题】看别人说是树形dp，但我怎么没看出来这和树形dp有什么关系，可能是因为我就做过一道树形dp的题目吧;0)，现在算是认识到了</p>
<pre class="highlight"><code class="language-c++">class Solution {
public:
    int ans = 1;
    int dfs(int u, vector&lt;vector&lt;int&gt;&gt; &amp;g, string &amp;s) {
        int maxLen = 1;
        for (int i = 0; i &lt; g[u].size(); i ++ ) {
            int len = dfs(g[u][i], g, s);
            if (s[u - 1] != s[g[u][i] - 1]) {
                ans = max(ans, len + maxLen);
                maxLen = max(maxLen, 1 + len);
            }
        }
        return maxLen;
    }

    int longestPath(vector&lt;int&gt;&amp; parent, string s) {
        int n = s.size();
        vector&lt;vector&lt;int&gt;&gt; g(n + 1);
        for (int i = 0; i &lt; n; i ++ )
            g[parent[i] + 1].push_back(i + 1);

        dfs(1, g, s);

        return ans;
    }
};</code></pre>
    </div>
    
            

    <div id="gitalk-container"></div>

        </div>
        <div id="footer">
            
            
        </div>
        

        
    <script src="/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
    <script>
        const gitalk = new Gitalk({
            clientID: '1c8b8a648872fb4b06e5',
            clientSecret: 'e7aa56cb8653e89050195484e973f5de0cb46781',
            repo: 'insorker.github.io', // The repository of store comments,
            owner: 'insorker',
            admin: ['insorker'],
            id: '1650341522.1336854', // Ensure uniqueness and length less than 50
            distractionFreeMode: false  // Facebook-like distraction free mode
        })
        gitalk.render('gitalk-container')
    </script>

    
    </div>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libco 年轻人的第一个协程</title>
    <link rel="shortcut icon" type="image/x-icon" href="/img/favicon.ico" />
    <link href="/css/yori.css" rel="stylesheet" />
    
    <link rel="stylesheet" href="/css/github-markdown.min.css">
    <link rel="stylesheet" href="/css/github.min.css">
    <style type="text/css">
        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }

        @media (max-width: 767px) {
            .markdown-body {
                padding: 15px;
            }
        }
    </style>

</head>
<body>
    <div class="container">
    
        <div id="content">
            
    <div class="content-header">
        <div class="post-title">
            libco 年轻人的第一个协程
        </div>
        <div class="post-meta">
            <span>insorker</span>
            <span> | posted on 2022-04-08</span>
        </div>
    </div>
    <div class="markdown-body">
        <h1 id="libco">libco 年轻人的第一个协程</h1>
<p><a href="http://jyywiki.cn/OS/2022/labs/M2">实验链接</a></p>
<h2 id="_1">失败后的反思</h2>
<p>有时候需要自己实际跌过跟头，回头看看才知道原来的方法是多么的愚蠢。就比如我这次协程的编写思路，完全和我糟糕的算法竞赛思路如出一辙——凑出一个思路——忽略细节，不做证明——简单验证一下可行性和复杂度——code。。。——交一遍——寄——看看哪里错了（有反馈就直接按错误测试数据调）——哦，傻逼了，赶紧改代码——再交一遍——啊哈，又寄了——哦，这儿忘了改了——再交一遍——哈哈，wa了三遍了，条件判断太多了，维护不了不做了</p>
<p>哦，错了这么多次都没能总结错在哪里，只能说是不聪明，但错了这么多次都不改，属实是又蠢又坏了。只能说接下来做题，除非简单题一眼出答案，一次ac，否则必打草稿，给出细节证明与思考，必验证正确性。</p>
<h2 id="_2">接口</h2>
<pre class="highlight"><code class="language-c">struct co *co_start(const char *name, void (*func)(void *), void *arg);
void       co_yield();
void       co_wait(struct co *co);</code></pre>
<p>先给出课程里的介绍：</p>
<ol>
<li><code>co_start(name, func, arg)</code>创建一个新的协程，并返回一个指向struct co的指针 (类似于<code>pthread_create</code>)。<br />
   - 新创建的协程从函数 <code>func</code> 开始执行，并传入参数 <code>arg</code>。新创建的协程不会立即执行，而是调用 <code>co_start</code> 的协程继续执行。<br />
   - 使用协程的应用程序不需要知道 <code>struct co</code> 的具体定义，因此请把这个定义留在 <code>co.c</code> 中；框架代码中并没有限定 <code>struct co</code> 结构体的设计，所以你可以自由发挥。<br />
   - <code>co_start</code> 返回的 <code>struct co</code> 指针需要分配内存。我们推荐使用 <code>malloc()</code> 分配。</li>
<li><code>co_wait(co)</code>表示当前协程需要等待，直到co协程的执行完成才能继续执行 (类似于<code>pthread_join</code>)。<br />
   - 在被等待的协程结束后、 <code>co_wait()</code> 返回前，<code>co_start</code> 分配的 <code>struct co</code> 需要被释放。如果你使用 <code>malloc()</code>，使用 <code>free()</code> 释放即可。<br />
   - 因此，每个协程只能被 <code>co_wait</code> 一次 (使用协程库的程序应当保证除了初始协程外，其他协程都必须被 <code>co_wait</code> 恰好一次，否则会造成内存泄漏)。</li>
<li><code>co_yield()</code> 实现协程的切换。协程运行后一直在 CPU 上执行，直到 <code>func</code> 函数返回或调用 <code>co_yield</code> 使当前运行的协程暂时放弃执行。<code>co_yield</code> 时若系统中有多个可运行的协程时 (包括当前协程)，你应当随机选择下一个系统中可运行的协程。</li>
<li><code>main</code> 函数的执行也是一个协程，因此可以在 <code>main</code> 中调用 <code>co_yield</code> 或 <code>co_wait</code>。<code>main</code> 函数返回后，无论有多少协程，进程都将直接终止。</li>
</ol>
<p>有些东西只有真正自己code了一遍才能理解，这里给出我的思考</p>
<p>先给出一些限制（解释一下，限制只的是编写代码的限制，不是对协程使用方式的限制，该怎么用还是按定义来，下面都是我自己的想法，可能是错的，但确实是我自己想的一套）：</p>
<ol>
<li>每个struct co只保存自己的上下文<br />
   - 可能你觉得这是废话，但为什么不能保存上一次过来的上下文呢？因为试想一下这种情况，我从协程A切换到协程B，B保存了A的上下文，那么从B切换到C再从C切换到A，将无法获得A的上下文（B的存在我是不知道的，而A的上下文在B处）<br />
   - 这个上下文可以是co_yield的，也可以是co_wait的</li>
<li>每个struct co运行结束后不能立刻回收内存<br />
   - 运行在自己的栈上，回收自己的栈，等同于我要保证我存在的情况下让自己不存在。。。</li>
<li>不能co_yield回到一个CO_DEAD或CO_WAITING状态下的协程<br />
   - 对于CO_DEAD，嗯，不然呢<br />
   - 对于CO_WAITING，详见第6条</li>
<li>每个struct co的func运行完毕后需要调用co_yield，且该co_yield永远不返回<br />
   - 这个比较好理解，func运行在struct co的栈上，如果结束，将没地方跳转（因为是通过stack_switch_call过来的），只能手动co_yield出去。这个时候如果返回还是那个问题，没地方跳转，而且不返回，最后也可以回收所有数据而不出现问题。</li>
<li>每个struct co保存的上下文是自己co_yield出去的上下文，或者自己co_wait的上下文<br />
   - 字面上没有问题，但为什么不能是co_wait出去的上下文？如果不是，那co_wait出去的上下文应该保存在哪里？（第二个问题后面回答）<br />
   - 首先证明一下确实可能同时存在两个上下文。考虑正在执行协程A的时候co_yield，保存上下文context1，进入协程B。协程B调用co_wait，协程A继续执行，执行完如果不返回协程B，那么协程B永远处于CO_WAITING的状态，永远不能被co_yield入（详见第3条）。如果想要返回协程B，那么协程A就必须保存协程B的context2，此时同时存在两个context。<br />
   - 也可以是co_wait出去的上下文，不过还是只能保存自己的，按照上面的分析，协程A还需要一个指针co_waiter指针指向协程B，否则不能返回协程B，协程B就寄了。</li>
<li>调用co_wait的struct co不能被co_yield，或co_wait<br />
   - 这句话是从co_wait的语义来讲，co_wait的协程（设为协程A）必须等待传入的struct co（设为B协程）运行结束，如果没有结束不能继续运行。<br />
   - 如果被co_yield进入，那么意味着在B结束前，A继续执行，违背了定义。所以co_yield直接不能进入正在waiting的struct co就行了。<br />
   - 如果被co_wait进入，那么意味着存在一个环，从A开始，到A结束。A等待协程B，协程B等待某个协程，以此类推（co_wait或co_yield进入其他协程），最后从某个协程进入A，这说明程序陷入死循环。所以这种情况是被禁止的。<br />
   - 不可能出现所有程序都在wait。基于上面的一点，不能wait一个waiting，所以不可能。</li>
<li>main函数的执行也是一个协程<br />
   - 如果上面那个感觉是废话，这个就显得有点匪夷所思了。只有你真正编程了才会理解。（但我认为这个定义还是图个方便，可有可无。）</li>
<li>co_yield和co_wait不能同时处于被调用的状态<br />
   - 从逻辑上不可能同时出现</li>
<li>co_yield可以切换到自己<br />
   - 理由是不这么做会很麻烦。你需要一个全局变量去保存当前运行的是哪个协程，切换的时候要改变这个全局变量，还要判断是不是切换到了自己。<br />
   - 第二是如果只有一个协程，就会死循环，自己不能切换到自己。<br />
   - 再者，协程是模仿线程的，线程就是随机切换执行，我们照着抄就行了。</li>
</ol>
<p>接下来是分析每个函数可能的情况</p>
<ol>
<li>
<p>co_yield可能出现如下情况<br />
   - co_yield到其他其他协程</p>
<ul>
<li>co_yield到CO_NEW</li>
<li>co_yield到CO_RUNNING</li>
<li>其他情况分析过，不可能出现，详见上述第3条</li>
<li>co_yield到自己</li>
<li>这个看起来有点搞，怎么切换出去还是切换到自己？请看第9条</li>
</ul>
</li>
<li>
<p>co_wait可能出现如下情况<br />
   - co_wait自己，显然是错的<br />
   - co_wait重复的协程，错误<br />
   - co_wait一个CO_DEAD的协程，同下面第3条的第2点<br />
   - co_wait一个CO_RUNNING or CO_NEW的协程，其实可以和上面一个合并。因为co最终总是要运行结束他的函数，然后设置为CO_DEAD，然后依据第3点判断。所以直接设一个函数co_switch_dead处理func运行结束的结果就可以了。</p>
</li>
<li>
<p>co的func运行结束怎么办？<br />
   - 如果没有waiter，设置状态为CO_DEAD，然后co_yield切换到别的协程<br />
   - 如果有waiter，切换到waiter的协程，由waiter协程free自己</p>
</li>
</ol>
<h2 id="_3">问题</h2>
<ol>
<li>玄学问题，在调用完stack_switch_call后，co-&gt;waiter的值就变了</li>
</ol>
<p>答：我是百思不得其解啊，调了很久的gdb，其他的值都对，就waiter不对，然后我把</p>
<pre class="highlight"><code class="language-c">jmp_buf        context; // 寄存器现场 (setjmp.h)
struct co *    waiter;  // 是否有其他协程在等待当前协程</code></pre>
<p>改成了</p>
<pre class="highlight"><code class="language-c">struct co *    waiter;  // 是否有其他协程在等待当前协程
jmp_buf        context; // 寄存器现场 (setjmp.h)</code></pre>
<p>问题就解决了？？？</p>
<ol start="2">
<li>这个问题其实是第一个问题的答案，但是面对第一个问题的我实在是太可爱了，舍不得删掉了</li>
</ol>
<p>答：真正的问题出在对栈的理解上，栈是从下往上增长的，那么你模拟栈的时候，用stack_switch_call是不是应该传入栈底而不是栈顶？即</p>
<pre class="highlight"><code class="language-c">stack_switch_call(co-&gt;stack + CO_STACK_SIZE, co_wrapper, (uintptr_t)co);</code></pre>
<ol start="3">
<li>最恐怖的错误，我的程序出现了间歇性抽风，一会儿能出结果，一会儿不能出结果</li>
</ol>
<p>答：答案是有段测试代码忘删了，[流汗黄豆吐舌]</p>
<h2 id="_4">代码</h2>
<p>忍不住贴出来了，感觉自己写的很吊</p>
<pre class="highlight"><code class="language-c">#include "co.h"
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;setjmp.h&gt;
#include &lt;string.h&gt;
#include &lt;assert.h&gt;
#include &lt;time.h&gt;

#define Assert(x, s) \
        do { if (!x) { printf("&gt; co assert: %s", s); assert(x); } } while(0)

static inline void stack_switch_call(void *sp, void *entry, uintptr_t arg) {
    asm volatile (
        #if __x86_64__
        "movq %0, %%rsp; movq %2, %%rdi; jmp *%1"
        : : "b"((uintptr_t)sp), "d"(entry), "a"(arg) : "memory"
        #else
        "movl %0, %%esp; movl %2, 4(%0); jmp *%1"
        : : "b"((uintptr_t)sp - 8), "d"(entry), "a"(arg) : "memory"
        #endif
    );
}

enum co_status {
    CO_NEW = 1,
    CO_RUNNING,
    CO_WAITING,
    CO_DEAD,
};
#define CO_STACK_SIZE (1 &lt;&lt; 16)
struct co {
    int  id;
    char *name;
    void (*func)(void *);
    void *arg;

    enum co_status  status;
    struct co *             waiter;
    jmp_buf                 context;
    uint8_t                 stack[CO_STACK_SIZE];
};

#define CO_POOL_SIZE 128
static struct co *current;
static struct co *co_pool[CO_POOL_SIZE];
static int co_pool_size;
static void co_pool_init() {
    for (int i = 0; i &lt; CO_POOL_SIZE; i ++ ) {
        co_pool[i] = NULL;
    }
    current = NULL;
}
static int co_pool_insert(struct co *co) {
    int success = 0;
    for (int i = 0; i &lt; CO_POOL_SIZE; i ++ ) {
        if (co_pool[i] == NULL) {
            co_pool[i] = co;
            co-&gt;id = i;
            success = 1;
            co_pool_size ++ ;
            break;
        }
    }
    return success;
}
static struct co *co_pool_next() {
    int start = rand() % co_pool_size;
    for (int i = start; i &lt; CO_POOL_SIZE + start; i ++ ) {
        struct co *next = co_pool[i % CO_POOL_SIZE];
        if (next == NULL)                               continue;
        if (next-&gt;status == CO_DEAD)    continue;
        if (next-&gt;status == CO_WAITING) continue;

        return next;
    }
    return NULL;
}
void co_free(struct co *co) {
    Assert((co != NULL), "should not free a NULL co pointer");

    co_pool[co-&gt;id] = NULL;
    co_pool_size -- ;

    if (!co-&gt;name) {
        free(co-&gt;name);
    }
    free(co);
}

static void co_main_init() {
    struct co *main = co_start("main", NULL, NULL);
    // main is just a concept to simulate the main function, not the real main
    main-&gt;status = CO_RUNNING;
    current = main;
}

static void co_switch_dead(struct co *co);
static void co_wrapper(void *arg) {
    struct co *co = (struct co *)arg;

    co-&gt;func(co-&gt;arg);
    co-&gt;status = CO_DEAD;
    co_switch_dead(co);
}

static void co_switch_new(struct co *co) {
    current = co;
    co-&gt;status = CO_RUNNING;
    stack_switch_call(co-&gt;stack + CO_STACK_SIZE, co_wrapper, (uintptr_t)co);
}
static void co_switch_running(struct co *co) {
    current = co;
    longjmp(co-&gt;context, 1);
}
static void co_switch_dead(struct co *co) {
    if (co-&gt;waiter != NULL) {
        longjmp(co-&gt;waiter-&gt;context, 1);
    }
    else {
        co_yield();
    }
}
static void co_switch_waiting(struct co *co) {
    Assert(0, "execute a waiting co. "
           "maybe a waiting circle has occured\n");
}
typedef void (*co_handler_t)(void *arg);
static void *co_switch[] = {
    [CO_NEW]                = co_switch_new,
    [CO_RUNNING]    = co_switch_running,
    [CO_DEAD]           = co_switch_dead,
    [CO_WAITING]    = co_switch_waiting,
};

struct co *co_start(const char *name, void (*func)(void *), void *arg) {
    struct co *co = (struct co *)malloc(sizeof(struct co));

    co-&gt;name = (char *)malloc(sizeof(name));
    strcpy(co-&gt;name, name);
    co-&gt;func = func;
    co-&gt;arg  = arg;

    co-&gt;status = CO_NEW;
    co-&gt;waiter = NULL;

    co_pool_insert(co);

    return co;
}

void co_yield() {
    /* jmp_buf buf; */
    /* int val = setjmp(buf); */
    int val = setjmp(current-&gt;context);

    if (val == 0) {
        struct co* next = co_pool_next();
        Assert((next != NULL), "next co to execute shouldn't be empty");

        ((co_handler_t)co_switch[next-&gt;status])(next);
    }
    else {
    }
}

void co_wait(struct co *co) {
    Assert((co != NULL), "wait a null co\n");
    Assert((co != current), "current co can't wait itself\n");

    int val = setjmp(current-&gt;context);

    if (val == 0) {
        current-&gt;status = CO_WAITING;
        co-&gt;waiter = current;
        ((co_handler_t)co_switch[co-&gt;status])(co);
    }
    else {
        co_free(co);
        current-&gt;status = CO_RUNNING;
    }
}

__attribute__((constructor)) void co_constructor() {
    srand((unsigned int)time(NULL));
    co_pool_init();
    co_main_init();
}

__attribute__((destructor)) void co_destructor() {
    co_free(co_pool[0]);
}</code></pre>
    </div>
    
            

        </div>
        <div id="footer">
            
            
        </div>
        

        
    <script src="/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    
    </div>
</body>
</html>
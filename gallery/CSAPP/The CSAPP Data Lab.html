<!DOCTYPE html>
<html lang="en">
<head>
    

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The CSAPP Data Lab</title>
    <link rel="shortcut icon" type="image/x-icon" href="/img/favicon.ico" />
    <link href="/css/yori.css" rel="stylesheet" />
    
    <link href="/css/prism.css" rel="stylesheet" />

</head>
<body>
    <div class="container">
    
        <div id="content">
            
    <div class="content-header">
        <div class="post-title">
            <h1>The CSAPP Data Lab</h1>
        </div>
        <div class="post-meta">
            <span>insorker</span>
            <span> | Posted on 2021-06-09</span>
        </div>
    </div>
    <div><h1 id="the-csapp-data-lab">The CSAPP Data Lab</h1>
<ul>
<li>insorker</li>
<li>2021/6/9</li>
</ul>
<h2 id="hello">Hello</h2>
<p>辞退了一些事情，现在成了无业游民，不过终是于闲下来了。也算一个新的开始，有点自己的时间做点喜欢的事情了</p>
<p>所以，你好，CSAPP！</p>
<h2 id="introduction">Introduction</h2>
<p>第一章的 Lab 是关于整数、浮点数在计算机内部的存储与计算。</p>
<p>虽然数据存储是一件很基础、很自然的事情，大部分时候我们甚至感觉不到它们的存在，因为被认为是理所应当（点名批评弱类型语言）。不过这些仍然很重要，数学计算的错误是非常严重的，可能会带来灾难性的后果，这里引用原文的例子：</p>
<p>哎，没举例呢，想看自己买一本实体书吧~</p>
<blockquote>
<p>提前约定一下，大写字母表示单个比特位，小写字母表示一串比特数据</p>
</blockquote>
<h2 id="problems">Problems</h2>
<h3 id="1-bitxor">1. bitXor</h3>
<pre class="highlight"><code class="language-cpp">/* 
 * bitXor - x^y using only ~ and &amp; 
 *   Example: bitXor(4, 5) = 1
 *   Legal ops: ~ &amp;
 *   Max ops: 14
 *   Rating: 1
 */
int bitXor(int x, int y) {
  return 2;
}</code></pre>
<blockquote>
<p>很遗憾，我查了很多地方都没有找到符号 ^ 的正确转义（<a href="https://www.onemathematicalcat.org/MathJaxDocumentation/TeXSyntax.htm">https://www.onemathematicalcat.org/MathJaxDocumentation/TeXSyntax.htm</a>），有人知道的话务必留言告诉我</p>
</blockquote>
<p>首先理解一下异或是什么<br />
$$<br />
A 异或 B = \overline{A}B + \overline{B}A<br />
$$<br />
取反和与题目是允许使用的，那么唯一的难点是如何创造出或</p>
<p>根据摩根定律我们可以把 &amp; 和 | 相互转换得到</p>
<pre class="highlight"><code class="language-cpp">A | B = ~((~A) &amp; (~B))</code></pre>
<p>所以，可得最终结果</p>
<pre class="highlight"><code class="language-cpp">int bitXor(int x, int y) {
  return ~(~(~x &amp; y) &amp; ~(~y &amp; x));
}</code></pre>
<h3 id="2-tmin">2. tmin</h3>
<pre class="highlight"><code class="language-cpp">/* 
 * tmin - return minimum two's complement integer 
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 4
 *   Rating: 1
 */
int tmin(void) {
  return 2;
}</code></pre>
<p>这题很简单啊，不解释</p>
<pre class="highlight"><code class="language-cpp">int tmin(void) {
  return 1 &lt;&lt; 31;
}</code></pre>
<h3 id="3-istmax">3. isTmax</h3>
<pre class="highlight"><code class="language-cpp">/*
 * isTmax - returns 1 if x is the maximum, two's complement number,
 *     and 0 otherwise 
 *   Legal ops: ! ~ &amp; ^ | +
 *   Max ops: 10
 *   Rating: 1
 */
int isTmax(int x) {
  return 2;
}</code></pre>
<blockquote>
<p>错误示范：</p>
<ol>
<li>! (x + x + 2) ：x = -1时候不行</li>
<li>!(x ^ ~(x + 1))：同理 x = -1 时候不行</li>
</ol>
</blockquote>
<p>除了错误示范，经过我的测试，还存在很多匪夷所思的地方，比如</p>
<pre class="highlight"><code class="language-cpp">int main() {
    int a;
    scanf("%d", &amp;a);
    // 0x7FFFFFFF
    printf("%d\n", !!(a + 1));
    printf("%d\n", (a + 1) + (a + 1));
    printf("%d\n", 0x7FFFFFFF);
    printf("%d\n", a);                  // &lt;- 在这里
    printf("%d\n", (a + 1));
    printf("%d\n", !!(a + 1) &amp; !(a + a + 2));
    printf("%d\n", isTmax(a));
    return 0;
}
/* 输入 */
0x7FFFFFFF
/* 输出 */
1
2
2147483647
0               // &lt;- 在这里
1
0
0</code></pre>
<p>虽然上面的问题没有解决，不过最后还是做出来了，只要把 -1 给排除掉就可以了</p>
<pre class="highlight"><code class="language-cpp">int isTmax(int x) {
  int is_negone  = !(x + 1);
  int is_tmax = !(~(x + 1 + x));
  return !is_negone &amp; is_tmax;
}</code></pre>
<h3 id="4-alloddbits">4. allOddBits</h3>
<pre class="highlight"><code class="language-cpp">/* 
 * allOddBits - return 1 if all odd-numbered bits in word set to 1
 *   where bits are numbered from 0 (least significant) to 31 (most significant)
 *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 12
 *   Rating: 2
 */
int allOddBits(int x) {
  return 2;
}</code></pre>
<blockquote>
<p>\1. Integer constants 0 through 255 (0xFF), inclusive. You are</p>
<p>not allowed to use big constants such as 0xffffffff.<br />
</p>
</blockquote>
<p>题目中有限制说明，所以不能直接使用 0xAAAAAAAA</p>
<p>しかし!</p>
<pre class="highlight"><code class="language-cpp">/* 这样总不能算我作弊吧 */
int y = 0xAA | (0xAA &lt;&lt; 8) | (0xAA &lt;&lt; 16) | (0xAA &lt;&lt; 24);</code></pre>
<p>然后就很简单了，先把所有为偶数位掩盖掉</p>
<pre class="highlight"><code class="language-cpp">(x &amp; y)</code></pre>
<p>然后判断结果是否与 0xAAAAAAAA 相等，最后答案就出来了</p>
<pre class="highlight"><code class="language-cpp">int allOddBits(int x) {
  int y = 0xAA | (0xAA &lt;&lt; 8) | (0xAA &lt;&lt; 16) | (0xAA &lt;&lt; 24);
  return !((x &amp; y) ^ y);
}</code></pre>
<h3 id="5-negate">5. negate</h3>
<pre class="highlight"><code class="language-cpp">/* 
 * negate - return -x 
 *   Example: negate(1) = -1.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 5
 *   Rating: 2
 */
int negate(int x) {
  return 2;
}</code></pre>
<p>简单题，补码的定义</p>
<pre class="highlight"><code class="language-cpp">int negate(int x) {
  return ~x + 1;
}</code></pre>
<h3 id="6-isasciidigit">6. isAsciiDigit</h3>
<pre class="highlight"><code class="language-cpp">/* 
 * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9')
 *   Example: isAsciiDigit(0x35) = 1.
 *            isAsciiDigit(0x3a) = 0.
 *            isAsciiDigit(0x05) = 0.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 15
 *   Rating: 3
 */
int isAsciiDigit(int x) {
  return 2;
}</code></pre>
<p>我的思路可能会比较奇怪</p>
<p>首先检验是否满足 0x30 的部分且其他高位为 0，然后检验是否小于 0x39</p>
<pre class="highlight"><code class="language-cpp">int isAsciiDigit(int x) {
  /* is bigger than 0x30 and smaller than 0x3F */
  int is_upper = !((x &amp; ~0x0F) ^ 0x30);
  /* is smaller than 0x39 */
  int is_lower = !((x &amp; 0x0F) + 0x06 &amp; 0xF0);
  return is_upper &amp; is_lower;
}</code></pre>
<p>Rua~~</p>
<h3 id="7-conditional">7. conditional</h3>
<pre class="highlight"><code class="language-cpp">/* 
 * conditional - same as x ? y : z 
 *   Example: conditional(2,4,5) = 4
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 16
 *   Rating: 3
 */
int conditional(int x, int y, int z) {
  return 2;
}</code></pre>
<p>这道题的最终答案可以说我最满意了，很对称，很优美</p>
<p>思路是自然而然冒出来的，灵感爆发了属于是</p>
<blockquote>
<p>最终输出很自然的想到：y 和 z 应该是或的关系，只要让一个变成 0 就行了</p>
<p>输入的处理也很自然的想到：让 x = 0 和 x != 0 自然的区分开</p>
</blockquote>
<pre class="highlight"><code class="language-cpp">int conditional(int x, int y, int z) {
  /* x =  0 =&gt; 0xFFFFFFFF
     x != 0 =&gt; 0x00 */
  int is_zero = ~!x + 1;
  int is_y = ~is_zero &amp; y;
  int is_z = is_zero  &amp; z;
  return is_y | is_z;
}</code></pre>
<h3 id="8-islessorequal">8. isLessOrEqual</h3>
<pre class="highlight"><code class="language-cpp">/* 
 * isLessOrEqual - if x &lt;= y  then return 1, else return 0 
 *   Example: isLessOrEqual(4,5) = 1.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 24
 *   Rating: 3
 */
int isLessOrEqual(int x, int y) {
  return 2;
}</code></pre>
<p>很简单啊，做个“减法”就好了</p>
<p>简单个毛啊，好难，要考虑 Tmin 还要考虑符号的正负性</p>
<p>不过还是做出来了，嘿嘿</p>
<pre class="highlight"><code class="language-cpp">int isLessOrEqual(int x, int y) {
  int neg_x = ~x + 1;
  int neg_y = ~y + 1;
  /* if x or y is neg, turn to pos */
  int negtpos_x = x &amp; ~(1 &lt;&lt; 31);
  int negtpos_y = y &amp; ~(1 &lt;&lt; 31);
  /* pos =&gt; 1 | neg =&gt; 0 */
  int sign_x = !(x &amp; (0x80 &lt;&lt; 24));
  int sign_y = !(y &amp; (0x80 &lt;&lt; 24));
  /* if success return 1
     else return 0 */
  int pos_pos = ( sign_x &amp;  sign_y) &amp; !(neg_x + y &amp; (0x80 &lt;&lt; 24));
  int pos_neg = 0;
  int neg_pos = (!sign_x &amp;  sign_y);
  int neg_neg = (!sign_x &amp; !sign_y) &amp; !(~negtpos_x + 1 + negtpos_y &amp; (0x80 &lt;&lt; 24));
  /* return */
  return pos_pos | pos_neg | neg_pos | neg_neg;
}</code></pre>
<p>不过还是有问题，符号数超了</p>
<blockquote>
<p>dlc:bits.c:248:isLessOrEqual: Warning: 37 operators exceeds max of 24</p>
</blockquote>
<p>问题不大，改一下得到下面的代码，确实改的过程中发现很多地方都是冗余的，比如</p>
<blockquote>
<p>判断 x 的符号：</p>
<ol>
<li>x &gt;&gt; 31</li>
<li>!(x &amp; (1 &lt;&lt; 31) )</li>
</ol>
<p>摩根定律：</p>
<ol>
<li>a | b</li>
<li>!a &amp; !b</li>
</ol>
</blockquote>
<pre class="highlight"><code class="language-cpp">int isLessOrEqual(int x, int y) {
  /* pos =&gt; 0 | neg =&gt; 1 */
  int sign_x = x &gt;&gt; 31;
  int sign_y = y &gt;&gt; 31;
  // int neg_y = ~y + 1;
  /* if x or y is neg, turn to pos */
  int negtpos_bias = ~(1 &lt;&lt; 31);
  int negtpos_x = x &amp; negtpos_bias;
  int negtpos_y = y &amp; negtpos_bias;
  /* if success return 1
     else return 0 */
  int pos_pos = !(( sign_x | sign_y) | (~x + 1 + y &gt;&gt; 31));
  // int pos_neg = 0;
  int neg_pos = ( sign_x &amp; !sign_y);
  int neg_neg = ( sign_x &amp;  sign_y) &amp; !(~negtpos_x + 1 + negtpos_y &gt;&gt; 31);
  /* return */
  return pos_pos | neg_pos | neg_neg;
}</code></pre>
<h3 id="9-logicalneg">9. logicalNeg</h3>
<pre class="highlight"><code class="language-cpp">/* 
 * logicalNeg - implement the ! operator, using all of 
 *              the legal operators except !
 *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1
 *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 12
 *   Rating: 4 
 */
int logicalNeg(int x) {
  return 2;
}</code></pre>
<p>看符号就行了，一个数的取正负后，首位必定是 1 或者是 0</p>
<p>对于特殊情况 Tmin，只要声称所有负数都为 0 就可以了</p>
<pre class="highlight"><code class="language-cpp">int logicalNeg(int x) {
  return (x &gt;&gt; 31 | (x ^ ~x + 1) &gt;&gt; 31) + 1;
}</code></pre>
<h3 id="10-howmanybits">10. howManyBits</h3>
<pre class="highlight"><code class="language-cpp">/* howManyBits - return the minimum number of bits required to represent x in
 *             two's complement
 *  Examples: howManyBits(12) = 5
 *            howManyBits(298) = 10
 *            howManyBits(-5) = 4
 *            howManyBits(0)  = 1
 *            howManyBits(-1) = 1
 *            howManyBits(0x80000000) = 32
 *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *  Max ops: 90
 *  Rating: 4
 */
int howManyBits(int x) {
  return 0;
}</code></pre>
<p>很遗憾，我尼玛题目都看不懂</p>
<p>不过，我看别人的解答，再加上自己的猜测，勉强给出了一个解释（虽然我仍然不清楚其中的逻辑）</p>
<blockquote>
<p>需要的比特数</p>
<ol>
<li>符号位（1）</li>
<li>数值位（31）</li>
</ol>
<p>如果是负数，对其取反计算（不消耗比特数）</p>
<p>如：howManyBits(0x80000001) =&gt; 32</p>
</blockquote>
<p>然后看前16位是否有1？若有，起码需要16位，故去掉后16位(右移16)，若没有，不移位</p>
<p>以此类推，形成二分法</p>
<p>此题我暂且保留意见，因为我还是没太搞懂它在让我干什么</p>
<pre class="highlight"><code class="language-cpp">int howManyBits(int x) {
  int sign = x &gt;&gt; 31;
  /* use conditional() before */
  {
    int y = ~x, z = x;
    int is_zero = ~!sign + 1;
    int is_y = ~is_zero &amp; y;
    int is_z = is_zero  &amp; z;
    x =  is_y | is_z;
  }
  int b16 = !!(x &gt;&gt; 16) &lt;&lt; 4;
  x = x &gt;&gt; b16;
  int b8  = !!(x &gt;&gt; 8 ) &lt;&lt; 3;
  x = x &gt;&gt; b8;
  int b4  = !!(x &gt;&gt; 4 ) &lt;&lt; 2;
  x = x &gt;&gt; b4;
  int b2  = !!(x &gt;&gt; 2 ) &lt;&lt; 1;
  x = x &gt;&gt; b2;
  int b1  = !!(x &gt;&gt; 1 ) &lt;&lt; 1;
  x = x &gt;&gt; b1;
  int b0 = x;
  return b16 + b8 + b4 + b2 + b1 + b0 + 1;
}</code></pre>
<h3 id="11-floatscale2">11. floatScale2</h3>
<pre class="highlight"><code class="language-cpp">/* 
 * floatScale2 - Return bit-level equivalent of expression 2*f for
 *   floating point argument f.
 *   Both the argument and result are passed as unsigned int's, but
 *   they are to be interpreted as the bit-level representation of
 *   single-precision floating point values.
 *   When argument is NaN, return argument
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while
 *   Max ops: 30
 *   Rating: 4
 */
unsigned floatScale2(unsigned uf) {
  return 2;
}</code></pre>
<p>说实话，乍一看会很懵，但其实就是考察你非常简单的知识点</p>
<p>我刚开始写的时候非常的乱，各种情况没考虑到</p>
<p>然后删了重写，一遍过（做法注释写的很清楚了）</p>
<blockquote>
<p>一定要记得使用 fshow，真的。。。它真的好好用。。。我哭死。。。</p>
</blockquote>
<pre class="highlight"><code class="language-cpp">unsigned floatScale2(unsigned uf) {
  unsigned bias_e = 0xFF;
  unsigned bias_m = (0x7F &lt;&lt; 16) + (0xFF &lt;&lt; 8) + 0xFF;
  unsigned sign = uf &gt;&gt; 31;
  unsigned e = (uf &gt;&gt; 23) &amp; bias_e;
  unsigned m = uf &amp; bias_m;

  /* if is 0 */
  if (!e &amp;&amp; !m) return uf;
  /* if is NaN or Max or Min */
  if (!(e ^ bias_e)) return uf;

  /* if unnormalized */
  if (!e) {
    m = m + m;
    if ((m &gt;&gt; 24) &amp; 1) {
      e = e + 1;
      m = m &amp; bias_m;
    }
  }
  /* if normalized */
  else
    e = e + 1;

  return (sign &lt;&lt; 31) + (e &lt;&lt; 23) + m;
}</code></pre>
<h3 id="12-floatfloat2int">12. floatFloat2Int</h3>
<pre class="highlight"><code class="language-cpp">/* 
 * floatFloat2Int - Return bit-level equivalent of expression (int) f
 *   for floating point argument f.
 *   Argument is passed as unsigned int, but
 *   it is to be interpreted as the bit-level representation of a
 *   single-precision floating point value.
 *   Anything out of range (including NaN and infinity) should return
 *   0x80000000u.
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while
 *   Max ops: 30
 *   Rating: 4
 */
int floatFloat2Int(unsigned uf) {
  return 2;
}</code></pre>
<p>这题我做出来了，但还是不太满意</p>
<p>要注意一下 1 &lt;&lt; x, (x &gt;= 32) 就溢出了，一定要小心，其他情况下直接输入给 int 就好了，让 int 自己判断</p>
<pre class="highlight"><code class="language-cpp">int floatFloat2Int(unsigned uf) {
  unsigned bias_e = 0xFF;
  unsigned bias_m = (0x7F &lt;&lt; 16) + (0xFF &lt;&lt; 8) + 0xFF;
  unsigned sign = uf &gt;&gt; 31;
  unsigned e = (uf &gt;&gt; 23) &amp; bias_e;
  unsigned m = uf &amp; bias_m;

  /* if unnormalized */
  int res = 0;
  if (!e)
    return 0;
  else {
    if (e &lt; 127)
      return 0;
      // res = (m + (1 &lt;&lt; 23)) / ((1 &lt;&lt; 23) * (1 &lt;&lt; (127 - e)));
    else if (e &lt;= 127 + 31)
      res = (m + (1 &lt;&lt; 23)) * (1 &lt;&lt; (e - 127)) / (1 &lt;&lt; 23);
    else
      res = 0x80000000;
  }

  /* add - */
  if (sign)
    res = -res;

  return res;
}</code></pre>
<h3 id="13-floatpower2">13. floatPower2</h3>
<pre class="highlight"><code class="language-cpp">/* 
 * floatPower2 - Return bit-level equivalent of the expression 2.0^x
 *   (2.0 raised to the power x) for any 32-bit integer x.
 *
 *   The unsigned value that is returned should have the identical bit
 *   representation as the single-precision floating-point number 2.0^x.
 *   If the result is too small to be represented as a denorm, return
 *   0. If too large, return +INF.
 * 
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while 
 *   Max ops: 30 
 *   Rating: 4
 */
unsigned floatPower2(int x) {
  return 2;
}</code></pre>
<p>思路很简单，就是往比特位上置一个 1 就好了，<del>唯一的难点是找到这个 1 的位置，因为其他全是 0 （有 1 吗）</del></p>
<pre class="highlight"><code class="language-cpp">unsigned floatPower2(int x) {
  unsigned res = 0;

  /* the minimun is 2^(-(1 - 127)) * 2^(-23) */
  if (x &lt; -23 - 126)
    return 0;
  /* the maximum is 2^(254 - 127) */
  if (x &gt; 127)
    return 0x7F800000;

  /* when unnormalized */
  if (x &lt; -126) {
    x = -x;
    res = res | 1 &lt;&lt; (x - 126);
  }
  /* when normalized and e is less than 127 */
  else if (x &lt;= 0) {
    x = -x;
    res = res | (127 - x) &lt;&lt; 23;
  }
  /* when normalized and e is more than 127 */
  else {
    res = res | (127 + x) &lt;&lt; 23;
  }

  return res;
}</code></pre>
<h2 id="the-end">The End</h2>
<p><img alt="在这里插入图片描述" src="https://gitee.com/insorker/image-host/raw/master/blog/CSAPP/datalab/2021061121474426.png" /></p>
<p>这两天虽然不是一直在做题，但还是做了好久好久，终于做完了，爽到！</p>
<p>其实题目并不是很难，也就是考察你对数的每一位的理解。</p>
<p>下一站：Bomb Lab</p></div>
    
            

        </div>
        <div id="footer">
            
            
        </div>
        

        
    <script src="/js/prism.js"></script>

    
    </div>
</body>
</html>